#!/bin/sh

# load vars
. lib/vars

# make sure all core dirs are present
mkdir -p "${DEFAULT_LOGDIR}"


debug () {
    if [ -n "${*}" ] && [ -n "${DEBUG}" ]; then
        ${PRINTF_BIN} "#%b%s%b\n" "${ColorDebug}" "${@}" "${ColorReset}" >&2
    fi
    return 0
}


warn () {
    if [ -n "${*}" ]; then
        ${PRINTF_BIN} "\n%b%s%b\n\n" "${ColorYellow}" "${@}" "${ColorReset}" >&2
    else
        ${PRINTF_BIN} "\n"
    fi
    return 0
}


note () {
    if [ -n "${*}" ]; then
        ${PRINTF_BIN} "\n%b%s%b\n" "${ColorGreen}" "${@}" "${ColorReset}" >&2
    else
        ${PRINTF_BIN} "\n"
    fi
    return 0
}


progress_note () {
    if [ -n "${*}" ]; then
        ${PRINTF_BIN} "${REPLAY_PREVIOUS_LINE}%b%s%b\n" "${ColorGreen}" "${@}" "${ColorReset}" >&2
    fi
    return 0
}


error () {
    if [ -n "${*}" ]; then
        ${PRINTF_BIN} "%b\n  %s %s\n    %b %b\n\n" "${ColorRed}" "${NoteChar}" "Task crashed!" "${0}: ${1}${2}${3}${4}${5}" "${ColorReset}" >&2
    else
        ${PRINTF_BIN} "%b\n  %s%b\n" "${ColorRed}" "ERROR!" "${ColorReset}" >&2
    fi
    exit 1
}


distd () {
    ${PRINTF_BIN} "%b%s%b" "${2:-${ColorDistinct}}" "${1}" "${3:-${ColorDebug}}" 2>/dev/null
    return 0
}


distn () {
    ${PRINTF_BIN} "%b%s%b" "${2:-${ColorDistinct}}" "${1}" "${3:-${ColorNote}}" 2>/dev/null
    return 0
}


distw () {
    ${PRINTF_BIN} "%b%s%b" "${2:-${ColorDistinct}}" "${1}" "${3:-${ColorWarning}}" 2>/dev/null
    return 0
}


diste () {
    ${PRINTF_BIN} "%b%s%b" "${2:-${ColorDistinct}}" "${1}" "${3:-${ColorError}}" 2>/dev/null
    return 0
}


# Make a varname from params
make_var_name () {
    if [ -n "${*}" ]; then
        ${PRINTF_BIN} "%s\n" "${*}" | ${SED_BIN} 's#[ ;:=%_/.-]#_#g' 2>/dev/null
    fi
}


# Make a varname from param and return held value
get_var_value () {
    if [ -n "${1}" ]; then
        eval "${PRINTF_BIN} '%s\n' \"\$$(make_var_name "${1}")\""
    fi
}


#
# Wrapper on "pass" utility to cache values in temporary cache
#
# First argument is string name of pass/cache element
# Example of 1st argument: "ops/ansible/notification-key"
#
pass_cache () {
    _key="${1}"
    if [ -z "${_key}" ] || [ -z "${PASS_BIN}" ]; then
        # Just return nothing and No-Op when no PASS_BIN defined or empty key given:
        return
    fi

    _cache_name="$(make_var_name "${_key}")"
    _cache_file="${DEFAULT_CACHE_FACTS_DIR}/${_cache_name}.facts"

    write_cache_file_if_value () {
        _value="$(${PASS_BIN} "${_key}" 2>/dev/null)"
        if [ -n "${_value}" ]; then
            mkdir -p "${DEFAULT_CACHE_FACTS_DIR}"
            echo "${_cache_name}=\"${_value}\"" | ${SED_BIN} 's/\n/\\ \n/g' 2>/dev/null > "${_cache_file}"
            echo "${_value}"
        fi
    }

    _cached_value="$(${CAT_BIN} "${_cache_file}" 2>/dev/null)"
    if [ -n "${_cached_value}" ]; then
        echo "${_cached_value#*=}" | ${SED_BIN} 's/^"//g; s/"$//g;' 2>/dev/null
    else
        write_cache_file_if_value
    fi
}


#
# Helper function to await for asynchronous parallel tasks
#
await_async () {
    _process_logs="${*}"
    _all="$(echo "${_process_logs}" | ${WC_BIN} -w 2>/dev/null | ${TR_BIN} -d ' ' 2>/dev/null)"
    debug "Awaiting background processes. Logs: $(distd "${_process_logs}")"
    _time_elapsed="0"

    note "â€¦"; note; note
    while true; do
        _completed="0"
        _failed="0"

        sleep 1
        for _plog in ${_process_logs}; do
            debug "Checking log: $(distd "${_plog}")"

            # Check for success:
            ${GREP_BIN} -E 'Reign completed:' "${_plog}" >/dev/null 2>&1
            if [ "0" = "${?}" ]; then
                _completed="$(echo "${_completed}+1" | ${BC_BIN} 2>/dev/null)"
            fi

            # Check for failure:
            ${GREP_BIN} -E 'Reign FAILED:' "${_plog}" >/dev/null 2>&1
            if [ "0" = "${?}" ]; then
                _failed="$(echo "${_failed}+1" | ${BC_BIN} 2>/dev/null)"
            fi
        done

        # If failed count >0 use red color:
        _fcolour="${ColorDistinct}"
        if [ "0" != "${_failed}" ]; then
            _fcolour="${ColorRed}"
        fi
        progress_note "Completed: $(distn "${_completed}"). Failed: $(distn "${_failed}" "${_fcolour}"). Total: $(distn "${_all}")  [elapsed: $(distn "${_time_elapsed}")s]"
        _time_elapsed="$(echo "${_time_elapsed}+1" | ${BC_BIN} 2>/dev/null)"
        _countall="$(echo "${_completed} + ${_failed}" | ${BC_BIN} 2>/dev/null)"
        debug "Done count: $(distd "${_countall}") of all: $(distd "${_all}")"
        if [ "${_countall}" = "${_all}" ]; then
            debug "Finished!"
            for _plog in ${_process_logs}; do
                note
                note "===>  Showing log: $(distn "${_plog}")"
                note "==================================================================================="
                ${CAT_BIN} "${_plog}"

                if [ -f "${_plog}.error" ] && [ -n "$(${CAT_BIN} "${_plog}.error" 2>/dev/null)" ]; then
                    warn "===>  Showing error log: $(distn "${_plog}")"
                    ${PRINTF_BIN} "%b\n%s %s\n    %b %b\n\n" "${ColorRed}" "${NoteChar}" "StdERR:" "$(${CAT_BIN} "${_plog}.error")" "${ColorReset}"
                fi
                note "==================================================================================="
                note
            done
            break
        fi

    done
}


# validate environment availability or crash
validate_env () {
    for _envvar in $(${CAT_BIN} lib/vars 2>/dev/null | ${GREP_BIN} -E "^.*[A-Z]+_BIN=\"\/.*\/.*\"" 2>/dev/null); do
        _vname="$(${PRINTF_BIN} '%s' "${_envvar}" | ${SED_BIN} 's/=.*$//' 2>/dev/null)"
        if [ -n "${_vname}" ]; then
            _val="$(eval "echo \$${_vname}")"
        else
            unset _val
        fi
        debug "validate_env('$(distd "${_vname}")'='$(distd "${_val}")')"
        if [ -n "${_val}" ] && [ ! -x "${_val}" ]; then
            error "Required binary is unavailable: $(diste "${_val}") on hostname: $(diste "${HOST_NAME}")"
        fi
    done
    unset _vname _val _envvar
}


# Cleanup of cached facts routine:
cleanup_fragile_facts () {
    debug "Invoking cleanup of fragile cached facts"
    for _fact_file in facts/cached/*.facts; do
        if [ "${DEFAULT_CACHE_FILE_LOCAL}" != "${_fact_file}" ]; then
            ${RM_BIN} -f "${_fact_file}"
        fi
    done
}
